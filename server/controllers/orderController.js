const Razorpay = require("razorpay");
const crypto = require("crypto");
const Order = require("../models/Order");
const MenuItem = require("../models/MenuItem");

// Initialize Razorpay instance
const razorpay = new Razorpay({
  key_id: process.env.RAZORPAY_KEY_ID,
  key_secret: process.env.RAZORPAY_KEY_SECRET,
});

/**
 * Create Order After Payment Verification
 * Verifies Razorpay payment signature and creates order in database
 *
 * POST /api/orders
 * Requires: authMiddleware
 */
exports.createOrder = async (req, res) => {
  try {
    const {
      items,
      totalAmount,
      paymentId,
      orderId,
      signature,
      deliveryOption,
      deliveryAddress,
    } = req.body;

    // Validation
    if (!items || !Array.isArray(items) || items.length === 0) {
      return res.status(400).json({
        error: "Invalid items",
        message: "Order must contain at least one item",
      });
    }

    if (!totalAmount || totalAmount <= 0) {
      return res.status(400).json({
        error: "Invalid amount",
        message: "Total amount must be greater than 0",
      });
    }

    if (!paymentId) {
      return res.status(400).json({
        error: "Missing payment details",
        message: "Payment ID is required",
      });
    }

    // Skip Razorpay verification for cash/temporary payments (development mode)
    const isCashPayment = paymentId.startsWith("CASH_");

    if (!isCashPayment && (!orderId || !signature)) {
      return res.status(400).json({
        error: "Missing payment details",
        message: "Order ID and signature are required for online payments",
      });
    }

    // Verify Razorpay signature only for online payments
    if (!isCashPayment) {
      const generatedSignature = crypto
        .createHmac("sha256", process.env.RAZORPAY_KEY_SECRET)
        .update(`${orderId}|${paymentId}`)
        .digest("hex");

      if (generatedSignature !== signature) {
        return res.status(400).json({
          error: "Payment verification failed",
          message: "Invalid payment signature",
        });
      }
    }

    // Verify items exist and are available
    const menuItemIds = items.map((item) => item.menuItemId);
    const menuItems = await MenuItem.find({
      _id: { $in: menuItemIds },
      isAvailable: true,
    });

    if (menuItems.length !== items.length) {
      return res.status(400).json({
        error: "Invalid items",
        message: "Some items are not available or do not exist",
      });
    }

    // Create order
    const order = new Order({
      userId: req.user._id,
      items: items.map((item) => ({
        menuItemId: item.menuItemId,
        name: item.name,
        price: item.price,
        qty: item.qty,
      })),
      totalAmount,
      paymentId,
      deliveryOption: deliveryOption || "dinein",
      deliveryAddress: deliveryAddress,
      status: "Pending",
      // tokenNumber will be auto-generated by pre-save hook
    });

    await order.save();

    // Populate user details
    await order.populate("userId", "name email");

    return res.status(201).json({
      success: true,
      message: "Order created successfully",
      data: order,
    });
  } catch (error) {
    console.error("Create Order Error:", error);
    return res.status(500).json({
      error: "Failed to create order",
      message: error.message,
    });
  }
};

/**
 * Get User's Orders
 * Returns all orders for the authenticated user
 *
 * GET /api/orders/my-orders
 * Requires: authMiddleware
 */
exports.getUserOrders = async (req, res) => {
  try {
    const orders = await Order.find({ userId: req.user._id })
      .populate("items.menuItemId")
      .sort({ createdAt: -1 }); // Newest first

    return res.status(200).json({
      success: true,
      count: orders.length,
      data: orders,
    });
  } catch (error) {
    console.error("Get User Orders Error:", error);
    return res.status(500).json({
      error: "Failed to fetch orders",
      message: error.message,
    });
  }
};

/**
 * Get All Orders
 * Admin only - returns all orders from all users
 *
 * GET /api/orders/all
 * Requires: authMiddleware, adminMiddleware
 */
exports.getAllOrders = async (req, res) => {
  try {
    const { status } = req.query;

    // Build query
    const query = {};
    if (status) {
      query.status = status;
    }

    const orders = await Order.find(query)
      .populate("userId", "name email")
      .populate("items.menuItemId")
      .sort({ createdAt: -1 }); // Newest first

    return res.status(200).json({
      success: true,
      count: orders.length,
      data: orders,
    });
  } catch (error) {
    console.error("Get All Orders Error:", error);
    return res.status(500).json({
      error: "Failed to fetch all orders",
      message: error.message,
    });
  }
};

/**
 * Get Single Order
 * Returns order details for a specific order
 * Users can only view their own orders, admins can view any order
 *
 * GET /api/orders/:id
 * Requires: authMiddleware
 */
exports.getOrder = async (req, res) => {
  try {
    const { id } = req.params;

    const order = await Order.findById(id)
      .populate("userId", "name email")
      .populate("items.menuItemId");

    if (!order) {
      return res.status(404).json({
        error: "Order not found",
      });
    }

    // Check if user owns this order or is admin
    if (
      order.userId._id.toString() !== req.user._id.toString() &&
      req.user.role !== "admin"
    ) {
      return res.status(403).json({
        error: "Forbidden",
        message: "You can only view your own orders",
      });
    }

    return res.status(200).json({
      success: true,
      data: order,
    });
  } catch (error) {
    console.error("Get Order Error:", error);
    return res.status(500).json({
      error: "Failed to fetch order",
      message: error.message,
    });
  }
};

/**
 * Update Order Status
 * Admin only - update order status (Pending -> Preparing -> Ready -> Completed)
 *
 * PATCH /api/orders/:id/status
 * Requires: authMiddleware, adminMiddleware
 */
exports.updateStatus = async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;

    // Validate status
    const validStatuses = ["Pending", "Preparing", "Ready", "Delivered"];
    if (!status || !validStatuses.includes(status)) {
      return res.status(400).json({
        error: "Invalid status",
        message: `Status must be one of: ${validStatuses.join(", ")}`,
      });
    }

    // Prepare update object
    const updateData = { status };

    // Set readyAt timestamp when order marked as Ready
    if (status === "Ready") {
      updateData.readyAt = new Date();
    }

    const order = await Order.findByIdAndUpdate(id, updateData, {
      new: true,
      runValidators: true,
    })
      .populate("userId", "name email")
      .populate("items.menuItemId");

    if (!order) {
      return res.status(404).json({
        error: "Order not found",
      });
    }

    return res.status(200).json({
      success: true,
      message: `Order status updated to ${status}`,
      data: order,
    });
  } catch (error) {
    console.error("Update Order Status Error:", error);
    return res.status(500).json({
      error: "Failed to update order status",
      message: error.message,
    });
  }
};

/**
 * Create Razorpay Order
 * Creates a Razorpay order for payment processing
 *
 * POST /api/orders/create-razorpay-order
 * Requires: authMiddleware
 */
exports.createRazorpayOrder = async (req, res) => {
  try {
    const { amount } = req.body;

    if (!amount || amount <= 0) {
      return res.status(400).json({
        error: "Invalid amount",
        message: "Amount must be greater than 0",
      });
    }

    // Create Razorpay order
    const options = {
      amount: amount * 100, // Razorpay expects amount in paise
      currency: "INR",
      receipt: `receipt_${Date.now()}`,
      payment_capture: 1,
    };

    const razorpayOrder = await razorpay.orders.create(options);

    return res.status(200).json({
      success: true,
      data: {
        orderId: razorpayOrder.id,
        amount: razorpayOrder.amount,
        currency: razorpayOrder.currency,
      },
    });
  } catch (error) {
    console.error("Create Razorpay Order Error:", error);
    return res.status(500).json({
      error: "Failed to create payment order",
      message: error.message,
    });
  }
};

/**
 * Cleanup Ready Orders
 * Automatically marks Ready orders older than 20 minutes as Delivered
 *
 * POST /api/orders/cleanup-ready
 * Requires: authMiddleware, adminMiddleware
 */
exports.cleanupReadyOrders = async (req, res) => {
  try {
    const twentyMinutesAgo = new Date(Date.now() - 20 * 60 * 1000);

    const result = await Order.updateMany(
      {
        status: "Ready",
        readyAt: { $lte: twentyMinutesAgo, $ne: null },
      },
      {
        status: "Delivered",
      }
    );

    return res.status(200).json({
      success: true,
      message: `Cleaned up ${result.modifiedCount} ready orders`,
      count: result.modifiedCount,
    });
  } catch (error) {
    console.error("Cleanup Ready Orders Error:", error);
    return res.status(500).json({
      error: "Failed to cleanup ready orders",
      message: error.message,
    });
  }
};
